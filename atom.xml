<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CatAndFish</title>
  
  <subtitle>123456</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://wty625073563.github.io/blog/"/>
  <updated>2020-07-23T15:24:29.187Z</updated>
  <id>https://wty625073563.github.io/blog/</id>
  
  <author>
    <name>Woods</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>修改博客主题样式</title>
    <link href="https://wty625073563.github.io/blog/2020/07/23/%E4%BF%AE%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F/"/>
    <id>https://wty625073563.github.io/blog/2020/07/23/修改博客主题样式/</id>
    <published>2020-07-23T15:21:52.000Z</published>
    <updated>2020-07-23T15:24:29.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于主题cafe修改配色"><a href="#基于主题cafe修改配色" class="headerlink" title="基于主题cafe修改配色"></a>基于主题cafe修改配色</h2><p>由于我最近挺喜欢win95的主题样式，所以，就衬下班有空的时间内部分改了cafe的主题样式</p><p>参考<a href="https://alexbsoft.github.io/win95.css/#" target="_blank" rel="noopener">win95</a></p>]]></content>
    
    <summary type="html">
    
      基于主题cafe修改配色
由于我最近挺喜欢win95的主题样式，所以，就衬下班有空的时间内部分改了cafe的主题样式

参考win95
    
    </summary>
    
    
      <category term="杂" scheme="https://wty625073563.github.io/blog/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>纪事</title>
    <link href="https://wty625073563.github.io/blog/2020/04/19/%E7%BA%AA%E4%BA%8B/"/>
    <id>https://wty625073563.github.io/blog/2020/04/19/纪事/</id>
    <published>2020-04-19T10:37:10.000Z</published>
    <updated>2020-06-06T11:22:55.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>呜呼哀哉，接近一年时间没有更新blog了。</p><p>最近干了啥，我自个也想复盘一下。</p><hr><h4 id="First"><a href="#First" class="headerlink" title="First"></a>First</h4><p>上一篇Todo，自己所立下的目标。<br>1、工作没换成，辗转反复，一直都在毕业以来的第一家公司。（最近离职了，不过还没找下家。）Why not leave before？</p><ul><li>钱的问题，但是每当都会以提薪酬挽留，这是其一？</li><li>情感的问题，不舍得？</li><li>能力提升的问题，还有继续学习提升的空间？</li></ul><p>以上是自己的疑问句，其实我内心并不希望自己复盘这种事情，或许俺是一个感性的人，又或许是这个利己社会主义中不成熟的异类</p><p>终究还是离职了，感谢我的公司。</p><p>2、3 都没有系统地去完成。</p><p>哈哈哈，时间过得很快，虽没有系统的地学习，但是学习到了更高效的学习方法，以目的为驱动，并不是以那种虚无缥缈的目标为驱动，是以现实所能快速呈现的产出为驱动。</p><p>类似我前端时间想做一个app，于是乎我按照我工作中的习惯的方式去执行，从0到1之间经历了很多，踩了很多坑，但是能不断完善自己的学习方式，执行方式，以及思维方式，非常的不错。最终以react-native，过程细节，后续肯定得记录下来。</p><p>4、第四点也没有，但是心中一直想着，只是优先程度并没有那么高，所以一直放着，但是这个得记下来。</p><p>5、路，有思路了。</p><h4 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h4><p>这接近一年的时间，虽然大部分在忙碌的工作中，但是我学到了神马新知识呢。</p><p>1、微信小程序、h5、企业微信小程序等多端合一的框架uni-app。<br>2、由于要做一个app，所以稍微学习了Java，了解了一下基础，但是没有继续深入。<br>3、学习了Node，Koa，Egg，最后使用了Egg，但对Node相关知识有了更多了解。<br>4、React React-native 做App。</p><p>个人也将语言真正定义为工具，什么语言不重要，重要的是在需要什么语言能最优解决我的需求。</p><p>但是</p><blockquote><p>书到用时方恨少，事非经过不知难。</p></blockquote><p>尽量不要让自己停下吸收知识。</p><h4 id="Third"><a href="#Third" class="headerlink" title="Third"></a>Third</h4><p>2020年，已然过了三分之一。无论是工作上，还是现实生活，家庭，都经历了很多事情，偶尔自怜自叹，偶尔逃避现实，虽不断挫败，但总该得面对现实。</p><p>加油呀！！</p><h4 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h4><p>真得把看书的计划提一提，不然写个东西，想不到更好的表达，只剩下WC。😁</p>]]></content>
    
    <summary type="html">
    
      Start
呜呼哀哉，接近一年时间没有更新blog了。

最近干了啥，我自个也想复盘一下。




First
上一篇Todo，自己所立下的目标。
1、工作没换成，辗转反复，一直都在毕业以来的第一家公司。（最近离职了，不过还没找下家。）Why not leave before？

 * 钱的问题，但是每当都会以提薪酬挽留，这是其一？
 * 情感的问题，不舍得？
 * 能力提升的问题，还有继续学习提升的空间？

以上是自己的疑问句，其实我内心并不希望自己复盘这种事情，或许俺是一个感性的人，又或许是这个利己社会主义中不成熟的异类

终究还是离职了，感谢我的公司。

2、3 都没有系统地去完成。


    
    </summary>
    
    
      <category term="杂" scheme="https://wty625073563.github.io/blog/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>Todo/目标，（短期/长期）</title>
    <link href="https://wty625073563.github.io/blog/2019/07/14/flag/"/>
    <id>https://wty625073563.github.io/blog/2019/07/14/flag/</id>
    <published>2019-07-14T06:13:34.000Z</published>
    <updated>2020-04-17T14:59:12.480Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、每天刷2-5道面试题</strong></p><p>初衷，想换工作了。。。</p><a id="more"></a><p><strong>2、温故而知新</strong></p><p>自己并不是科班出身，对于计算机相关的基础并不是很牢固。<br>其次，我一直对于基础而言，有个疑问，什么才算是“基础知识”，就JavaScript而言，什么才算是基础知识牢固呢。</p><p>与我现在这个阶段而言，心里没有底，所以需要不断网络搜索或者看书籍，加深自己对于此的宏观理解和记忆，加油吧少年。</p><p>所以近期先刷一遍：<a href="https://zh.javascript.info/" target="_blank" rel="noopener">现代 JavaScript 教程</a></p><p><strong>3、对现在流行的框架类库进行底层的了解/解析</strong></p><p>由于我刚入门的时候就是针对小程序进行开发，比较少接触传统的前端开发，比如web端和移动端的。<br>而到现在2年时间过去，过程中虽然做得最多得还是小程序项目，但也有做一些pc后台，web站点，还有一些h5站点等。虽然对于这些传统的项目，都会开发，流行的vue，react等都会使用，但并不是特别理解底层的原理，所以挺差劲的。</p><p>近期需要做的：<br>先分析vue的响应式原理，及vue3.0所用的代理技术。<br>其次看一遍，underscore.js的源码，顺便翻译以下，恶补以下自己的英语水平。</p><p><strong>4、开发自己的hexo主题</strong></p><p>我当初选择前端入门的时候，就是因为被一些网站炫酷的东西所吸引，虽说过了一段时间，审美偏好有所改变，不是特别喜欢炫酷的了，更会喜欢一些简洁明了的设计，例如<a href="https://evanyou.me/" target="_blank" rel="noopener">Evan You</a>，这是尤玉溪先生的博客。</p><p>不是特别喜欢我所能搜索到的hexo主题，所以自己想尝试做一下。</p><p><strong>5、选择自己的路</strong></p><p>。</p>]]></content>
    
    <summary type="html">
    
      1、每天刷2-5道面试题

初衷，想换工作了。。。

2、温故而知新

自己并不是科班出身，对于计算机相关的基础并不是很牢固。
其次，我一直对于基础而言，有个疑问，什么才算是“基础知识”，就JavaScript而言，什么才算是基础知识牢固呢。

与我现在这个阶段而言，心里没有底，所以需要不断网络搜索或者看书籍，加深自己对于此的宏观理解和记忆，加油吧少年。

所以近期先刷一遍：现代 JavaScript 教程

3、对现在流行的框架类库进行底层的了解/解析

由于我刚入门的时候就是针对小程序进行开发，比较少接触传统的前端开发，比如web端和移动端的。
而到现在2年时间过去，过程中虽然做得最多得还
    
    </summary>
    
    
      <category term="杂" scheme="https://wty625073563.github.io/blog/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>防抖和节流解析</title>
    <link href="https://wty625073563.github.io/blog/2019/06/05/%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://wty625073563.github.io/blog/2019/06/05/函数防抖和节流解析/</id>
    <published>2019-06-05T02:48:18.000Z</published>
    <updated>2020-04-20T06:29:32.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><ul><li>函数防抖/节流的概念</li><li>概念总结</li></ul><a id="more"></a><ul><li><p>函数防抖</p><ol><li>非立即执行防抖</li><li>立即执行防抖</li><li>最终</li></ol></li><li><p>函数节流</p><ol><li>时间戳版</li><li>定时器版</li><li>最终</li></ol></li></ul><hr><p>现在需要我们来发挥想象力👌</p><p>现在有两个<strong>假设，记住这两个假设，下面都会使用这些假设来理解概念。</strong><br><strong>假设1</strong> ：我们设定观察时间为10秒。规定1秒作为一次事件的时间间隔，也就是说，1秒内只能执行一次事件。<br>而触发事件的频率是0.5秒一次。<em>（频率：就是触发事件之后到下一次触发事件之间的间隔时间）</em></p><p><strong>假设2</strong>：在假设1的基础上，修改触发事件的频率为<strong>2秒1次</strong>。</p><hr><h4 id="事件防抖概念"><a href="#事件防抖概念" class="headerlink" title="事件防抖概念"></a>事件防抖概念</h4><blockquote><p>抽象概念： <strong>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</strong></p></blockquote><p>将这个概念代入上面的假设，我们实现的目标就是：在事件被触发1秒后，再执行回调，如果在1秒内又被触发，则重新计时。</p><p>在假设1中，触发频率为0.5秒，所以可以知道：在0 — 1秒这时间段，计时到0.5秒时触发了一次，导致又需要重新计时（归零）。<br><strong>防抖导致的最终结果就是</strong>，没有一次能完整地计时到1秒，所以没有一次能执行回调，没有一次能执行成功。</p><p>而假设2：触发频率2秒一次，所以：在0 — 1秒内，并没有触发，ok，触发的频率已经过了1秒了，还剩下1秒就要触发了，在第二个1秒范围内，2秒触发频率到了，开始执行。</p><h4 id="事件节流概念"><a href="#事件节流概念" class="headerlink" title="事件节流概念"></a>事件节流概念</h4><blockquote><p>抽象概念：<strong>规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</strong></p></blockquote><p>同样实际代入，目标：规定在1秒内，只能由一次出发时间的回调函数执行，如果在1秒内某事件多次被触发，只有一次生效。</p><p>触发频率为0.5秒。所以很好理解为：在1秒内，第一个0.5秒触发回调函数，第二个0.5秒触发被拦截。<br><strong>所以节流最终的结果就是：</strong> 0.5秒触发回调函数执行，1秒内只有一次事件执行。</p><hr><h4 id="两个概念对比下来进行通俗地总结："><a href="#两个概念对比下来进行通俗地总结：" class="headerlink" title="两个概念对比下来进行通俗地总结："></a>两个概念对比下来进行通俗地总结：</h4><blockquote><p>函数防抖：就是在函数在特定的时间内不被调用之后再去执行。<br>函数节流：限制函数在一定时间内调用的次数。</p></blockquote><hr><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (timer) clearTimeout(timer)<br>        <br>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params"><code class="language-hljs javascript"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (timer) clearTimeout(timer)<br>        <br>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> fn(...args), delay)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为什么使用闭包呢？</p><p>关键在于timer和clearTimeout。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><br><span class="hljs-comment">// 错误写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce1</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer1;<br>    clearTimeout(timer1);<br>    timer1 = setTimeout(fn, delay);<br>&#125;<br><br><span class="hljs-comment">// 简单写法，但timer2暴露在全局作用域下，debounce2这个函数就不是可复用的，只能给一个事件使用。</span><br><span class="hljs-keyword">let</span> timer2;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce2</span>(<span class="hljs-params"><code class="language-hljs javascript"><br><span class="hljs-comment">// 错误写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce1</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer1;<br>    clearTimeout(timer1);<br>    timer1 = setTimeout(fn, delay);<br>&#125;<br><br><span class="hljs-comment">// 简单写法，但timer2暴露在全局作用域下，debounce2这个函数就不是可复用的，只能给一个事件使用。</span><br><span class="hljs-keyword">let</span> timer2;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce2</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    clearTimeout(timer2);<br>    timer2 = setTimeout(fn, delay);<br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><br><span class="hljs-comment">// setTimeout版本</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle1</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span><br>        <br>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            fn(...args)<br>            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空</span><br>        &#125;, delay)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 时间戳实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle2</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> args = argumenus, now = <span class="hljs-built_in">Date</span>.now()<br>        <span class="hljs-keyword">if</span> (now - previous &gt; delay) &#123;<br>            fn(...args)<br>            previous = now<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><code class="language-hljs javascript"><br><span class="hljs-comment">// setTimeout版本</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle1</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span><br>        <br>        timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            fn(...args)<br>            timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空</span><br>        &#125;, delay)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 时间戳实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle2</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">const</span> args = argumenus, now = <span class="hljs-built_in">Date</span>.now()<br>        <span class="hljs-keyword">if</span> (now - previous &gt; delay) &#123;<br>            fn(...args)<br>            previous = now<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*<br>题外话：<br>throttle2函数中匿名函数中的 now 变量放在外面<br>会怎样？<br>这里考察了作用域和闭包的问题。<br>*/</span><br></code></pre></td></tr></table></figure><h4 id="总结-应用场景"><a href="#总结-应用场景" class="headerlink" title="总结/应用场景"></a>总结/应用场景</h4><p>网上有很多，而且针对一些常用的场景，也有一定的分歧。</p><blockquote><p>二者都是用来<strong>解决代码短时间内大量重复调用的方案</strong><br>各有利弊，各自权衡。</p></blockquote><p>参考文章：<br><a href="https://web.blued.cn/2018/03/10/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96/" target="_blank" rel="noopener">函数节流与函数防抖</a><br><a href="https://segmentfault.com/a/1190000018445196" target="_blank" rel="noopener">彻底弄懂函数防抖和函数节流</a></p><p>另外：以上的函数防抖和节流的方法都是一些比较简单且有一定缺陷。<br>稍微复杂一点的可以参考此篇文章：<br><a href="https://segmentfault.com/a/1190000017227559" target="_blank" rel="noopener">函数防抖(debounce)和节流(throttle)以及lodash的debounce源码赏析</a></p>]]></content>
    
    <summary type="html">
    
      防抖和节流
 * 函数防抖/节流的概念
 * 概念总结

 * 函数防抖
   
    1. 非立即执行防抖
    2. 立即执行防抖
    3. 最终
   
   
 * 函数节流
   
    1. 时间戳版
    2. 定时器版
    3. 最终
   
   




现在需要我们来发挥想象力👌

现在有两个假设，记住这两个假设，下面都会使用这些假设来理解概念。
假设1 ：我们设定观察时间为10秒。规定1秒作为一次事件的时间间隔，也就是说，1秒内只能执行一次事件。
而触发事件的频率是0.5秒一次。（频率：就是触发事件之后到下一次触发事件之间的间隔时间）

假设2：在假设
    
    </summary>
    
    
      <category term="JavaScript 性能优化" scheme="https://wty625073563.github.io/blog/tags/JavaScript-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>em 和 rem的区别，何时使用/实际应用</title>
    <link href="https://wty625073563.github.io/blog/2019/06/01/em%E5%92%8Crem/"/>
    <id>https://wty625073563.github.io/blog/2019/06/01/em和rem/</id>
    <published>2019-06-01T05:59:10.000Z</published>
    <updated>2020-04-17T14:59:12.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="em-和-rem的区别，何时使用-实际应用。"><a href="#em-和-rem的区别，何时使用-实际应用。" class="headerlink" title="em 和 rem的区别，何时使用/实际应用。"></a>em 和 rem的区别，何时使用/实际应用。</h3><p>网上有很多资料，此处只简要概括下和值得注意的地方</p><a id="more"></a><h4 id="1、区别"><a href="#1、区别" class="headerlink" title="1、区别"></a>1、区别</h4><p>rem：<br>使用rem单位时，像素值根据根元素，即根<strong>HTML</strong>元素的字体大小决定<br>而当根<strong>HTML</strong>元素没有设置固定值去覆盖，那么字体大小首先来自<strong>浏览器设置</strong>。</p><p>E.g：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre class=" language-hljs css"><code class="language-hljs css">html &#123;<br>    font-size: 16px;<br>&#125;<br>div &#123;<br>    font-size: 1rem;<br>    border-size: 1rem;<br>    width: 1rem;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></p><p>em：<br>使用em单位时，像素值将是<strong>em值乘以使用em单位的元素</strong>的字体大小</p><p>很多教程说是根据父元素决定，但其实不然；<br>之所以部分认为是父元素决定，是因为使用em单位的当前元素并没有设置像素值，需要去继承父元素，导致表象像是根据父元素的像素值大小而变化。</p><p>E.g：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;<br>&#125;<br><span class="hljs-selector-class">.child1</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1em</span>;<br>&#125;<br><span class="hljs-selector-class">.child2</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>; <span class="hljs-comment">/* 20px */</span><br>&#125;<br><span class="hljs-selector-class">.child3</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>; <span class="hljs-comment">/* 1.2 * 15px = 18px */</span><br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>; <span class="hljs-comment"><code class="language-hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;<br>&#125;<br><span class="hljs-selector-class">.child1</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1em</span>;<br>&#125;<br><span class="hljs-selector-class">.child2</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>; <span class="hljs-comment">/* 20px */</span><br>&#125;<br><span class="hljs-selector-class">.child3</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>; <span class="hljs-comment">/* 1.2 * 15px = 18px */</span><br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">1em</span>; <span class="hljs-comment">/* 18px */</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="2、应用（建议）"><a href="#2、应用（建议）" class="headerlink" title="2、应用（建议）"></a>2、应用（建议）</h4><p>文章中各有各的方法，此处只参考个人认为首选的方法。</p><ol><li>根据某个元素的字体大小做缩放而不是根元素的字体大小</li><li>只在标识清楚的情况下使用em</li><li>字体大小一般不适用em单位控制</li><li>一切可扩展都应该使用rem单位</li><li>媒体查询中使用rem单位</li><li>多列布局中使用 %</li></ol><p>其实以上几点都是互相影响，作用。<br>可以想象一个栗子</p><p>页面布局在组件化思维下：<br>一个组件在缩放时，应该根据当前组件的字体大小做缩放，所以在这种实际场景中，除了字体大小font-size这个属性外，其他例如，padding，margin等属性就需要使用em 单位。</p><p>而这时候的font-size属性需要rem 单位控制，当浏览器缩放时，根元素字体大小改变，对应组件字体大小改变，从而改变组件的ui布局。</p><p>更多详情可参考：<br><a href="https://webdesign.tutsplus.com/zh-hans/tutorials/comprehensive-guide-when-to-use-em-vs-rem--cms-23984" target="_blank" rel="noopener">综合指南: 何时使用 Em 与 Rem</a></p>]]></content>
    
    <summary type="html">
    
      em 和 rem的区别，何时使用/实际应用。
网上有很多资料，此处只简要概括下和值得注意的地方

1、区别
rem：
使用rem单位时，像素值根据根元素，即根HTML元素的字体大小决定
而当根HTML元素没有设置固定值去覆盖，那么字体大小首先来自浏览器设置。

E.g：
1
2
3
4
5
6
7
8
9


html {
    font-size: 16px;
}
div {
    font-size: 1rem;
    border-size: 1rem;
    width: 1rem;
    ...
}




em：
使用em单位时，像素值将是em值乘以使用em单位的元素的字
    
    </summary>
    
    
      <category term="CSS" scheme="https://wty625073563.github.io/blog/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>阅读汤姆大叔的深入理解JavaScript系列要点</title>
    <link href="https://wty625073563.github.io/blog/2019/05/25/%E9%98%85%E8%AF%BB%E6%B1%A4%E5%A7%86%E5%A4%A7%E5%8F%94%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B3%BB%E5%88%97%E8%A6%81%E7%82%B9/"/>
    <id>https://wty625073563.github.io/blog/2019/05/25/阅读汤姆大叔的深入理解JavaScript系列要点/</id>
    <published>2019-05-25T05:49:54.000Z</published>
    <updated>2020-04-17T14:59:12.482Z</updated>
    
    <content type="html"><![CDATA[<h4 id="系列1"><a href="#系列1" class="headerlink" title="系列1"></a>系列1</h4><h6 id="1、忘记var的副作用"><a href="#1、忘记var的副作用" class="headerlink" title="1、忘记var的副作用"></a>1、忘记var的副作用</h6><ul><li>通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。</li><li>无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。</li></ul><a id="more"></a><h6 id="2、访问全局对象"><a href="#2、访问全局对象" class="headerlink" title="2、访问全局对象"></a>2、访问全局对象</h6><p>意思是统一全局对象的变量名<br>例如在开发js库的时候，不同的环境下，浏览器/Node，or 严格模式下能够统一通过使用相同的变量名访问全局对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><span class="hljs-keyword">var</span> global = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword"><code class="language-hljs javascript"><span class="hljs-keyword">var</span> global = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;());<br></code></pre></td></tr></table></figure></p><h6 id="3、单var-let-const形式"><a href="#3、单var-let-const形式" class="headerlink" title="3、单var/let/const形式"></a>3、单var/let/const形式</h6><p>在函数顶部是使用单个语句声明变量，好处在于：</p><ul><li>易读</li><li>防止<strong>变量提升</strong>逻辑错误</li><li>少点代码</li></ul><p><strong>变量提升</strong>：<br>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(global);<span class="hljs-comment">// undefined</span><br>    <span class="hljs-keyword">var</span> global = <span class="hljs-string">'global'</span>;<br>    <span class="hljs-built_in">console</span>.log(global); <span class="hljs-comment">// global</span><br>&#125;<br>test()<br><br><span class="hljs-comment">// 等价于：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> global;<br>    <span class="hljs-built_in">console</span>.log(global)<br>    <span class="hljs-keyword">var</span> global = <span class="hljs-string">'global'</span>;<br>    <span class="hljs-built_in">console</span>.log(global); <span class="hljs-comment">// global</span><br>&#125;<br>test1()<br><span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(global);<span class="hljs-comment">// undefined</span><br>    <span class="hljs-keyword">var</span> global = <span class="hljs-string">'global'</span>;<br>    <span class="hljs-built_in">console</span>.log(global); <span class="hljs-comment">// global</span><br>&#125;<br>test()<br><br><span class="hljs-comment">// 等价于：</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> global;<br>    <span class="hljs-built_in">console</span>.log(global)<br>    <span class="hljs-keyword">var</span> global = <span class="hljs-string">'global'</span>;<br>    <span class="hljs-built_in">console</span>.log(global); <span class="hljs-comment">// global</span><br>&#125;<br>test1()<br><span class="hljs-comment">/* <br>* 原因：<br>* js解析器在解析阶段，把所有的声明提升到顶端后（hoisting）再执行。<br>* 文章中的“var散布的问题”有提及到<br>*/</span><br></code></pre></td></tr></table></figure><h6 id="4、for循环"><a href="#4、for循环" class="headerlink" title="4、for循环"></a>4、for循环</h6><p>若使用for来循环DOM节点对象，最好是先声明DOM节点对象的长度。避免在每一次遍历过程都实时查询DOM，影响性能。</p><h5 id="5、for-in"><a href="#5、for-in" class="headerlink" title="5、for-in"></a>5、for-in</h5><p>for-in应该使用在非数组对象的遍历上，需要跟for-of区分开来，避免混淆<br>for-in另称为“枚举”<br>不推荐使用其遍历数组<br>for-in的属性遍顺序是不能保证的<br>for-in会枚举对象原型链上的属性，需要用hasOwnProperty()过滤<br><strong>（object.hasOwnProperty(object[key])）</strong></p><p>ps:<br>例子中使用了<strong>Object.prototype.hasOwnProperty.call（man, i）</strong>来过滤，而不直接选择<strong>man.hasOwnProperty(i)</strong><br>查了一下资料说，</p><blockquote><p>如果使用 Object.create(null) 创建的对象是没有prototype的，所以是没有任何方法的，这种情况下，调用上述方法只会得到 undefined。</p></blockquote><p>但我的疑问是，既然已经用了for-in进行枚举对象，那如果没有prototype的话，那就根本不用去过滤了，man这个对象就没有prototype，这不就多此一举了吗？<br>这是我不理解的地方。</p><h6 id="6、避免隐式类型转换"><a href="#6、避免隐式类型转换" class="headerlink" title="6、避免隐式类型转换"></a>6、避免隐式类型转换</h6><p>如题，在我接触的实际业务中，大部分都是出现在判断的情况下。<br>与其说尽量，还不如直接忘记“==”这个符号，之后都是用全等于“===”来进行判断，除非逼不得已。</p><h6 id="7、parseInt"><a href="#7、parseInt" class="headerlink" title="7、parseInt()"></a>7、parseInt()</h6><p>为了避免矛盾和意外的结果，总是指定基数参数。</p><p><a href="https://www.cnblogs.com/TomXu/archive/2011/12/28/2286877.html" target="_blank" rel="noopener">深入理解JavaScript系列（1）：编写高质量JavaScript代码的基本要点</a></p><h4 id="系列2"><a href="#系列2" class="headerlink" title="系列2"></a>系列2</h4><p>emmmm….系列二前面还好，后面越看越迷糊。之后有机会仔细再研究这个系列。</p><h4 id="系列3-全面解析Module模式"><a href="#系列3-全面解析Module模式" class="headerlink" title="系列3 全面解析Module模式"></a>系列3 全面解析Module模式</h4><p>什么是Module模式，什么是模式。<br>由此引申出“设计模式”这个概念<br>参考：<a href="https://www.kancloud.cn/kancloud/learn-js-design-patterns/56469&quot;%3Ehttps://www.kancloud.cn/kancloud/learn-js-design-patterns/56469%3C" target="_blank" rel="noopener">什么是设计模式？</a></p><p>而Module模式，则是设计模式中“模块化模式”中的一种。<br>详细需要<a href="https://www.kancloud.cn/kancloud/learn-js-design-patterns/56469&quot;%3Ehttps://www.kancloud.cn/kancloud/learn-js-design-patterns/56469%3C" target="_blank" rel="noopener">链接</a></p><p>往后 大叔系列25-系列44都需要参考各样的资料。<br>“模式”的概念对于我来说现阶段较为庞大，后续再去深入理解。</p><h4 id="系列4-立即调用的函数表达式"><a href="#系列4-立即调用的函数表达式" class="headerlink" title="系列4 立即调用的函数表达式"></a>系列4 立即调用的函数表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><br>（<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;()） <span class="hljs-comment"><code class="language-hljs javascript"><br>（<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* do something */</span> &#125;()） <span class="hljs-comment">// TOM大叔推荐写法</span><br></code></pre></td></tr></table></figure><p>我认为，在实际工作中只需要明白<strong>立即调研的函数表达式</strong>主要的作用/目的：<br>首先看一个例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><br>(funcition () &#123; <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>; b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(a) &#125; &#125;)<br>a <span class="hljs-comment">// a is not defined</span><br>b() <span class="hljs-comment"><code class="language-hljs javascript"><br>(funcition () &#123; <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>; b = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(a) &#125; &#125;)<br>a <span class="hljs-comment">// a is not defined</span><br>b() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></p><p>上面的例子中，表达式a变成局部变量，形成闭包，只有调用b函数才能访问变量a。<br>这样隔断了作用域，防止了变量名的污染。</p><p>实际应用：<br>参考：<a href="https://www.cnblogs.com/teamobaby/p/4000618.html" target="_blank" rel="noopener">自执行函数引用</a></p><h4 id="系列5-原型和原型链"><a href="#系列5-原型和原型链" class="headerlink" title="系列5 原型和原型链"></a>系列5 原型和原型链</h4><p>待定。</p>]]></content>
    
    <summary type="html">
    
      系列1
1、忘记var的副作用
 * 通过var创建的全局变量（任何函数之外的程序中创建）是不能被删除的。
 * 无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。

2、访问全局对象
意思是统一全局对象的变量名
例如在开发js库的时候，不同的环境下，浏览器/Node，or 严格模式下能够统一通过使用相同的变量名访问全局对象。
1
2
3


var global = (function() {
    return this
}());




3、单var/let/const形式
在函数顶部是使用单个语句声明变量，好处在于：

 * 易读
 * 防止变量提升逻辑错误
 * 少
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wty625073563.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>valueOf</title>
    <link href="https://wty625073563.github.io/blog/2019/05/05/valueOf/"/>
    <id>https://wty625073563.github.io/blog/2019/05/05/valueOf/</id>
    <published>2019-05-05T15:48:18.000Z</published>
    <updated>2020-04-17T14:59:12.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><a id="more"></a><p>valueOf方法是将对象转换为“原始值”</p><p>默认情况下，valueOf方法由Object后面的每个对象继承。</p><p>如果对象没有原始值，则valueOf将返回对象本身。</p><table><thead><tr><th><strong>对象</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td><strong>Array</strong></td><td>返回数组对象本身</td></tr><tr><td><strong>Boolean</strong></td><td>布尔值</td></tr><tr><td><strong>Date</strong></td><td>存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。</td></tr><tr><td><strong>Function</strong></td><td>函数本身</td></tr><tr><td><strong>Number</strong></td><td>数值</td></tr><tr><td><strong>Object</strong></td><td>对象本身</td></tr><tr><td><strong>String</strong></td><td>字符串值</td></tr><tr><td></td><td>Math 和 Error 对象没有valueOf方法</td></tr></tbody></table><h6 id="什么是原始值"><a href="#什么是原始值" class="headerlink" title="什么是原始值"></a>什么是原始值</h6><p>在ECMAScript中，变量可以存在两种<strong>类型</strong>的值，即原始值和引用值。</p><p><strong>原始值</strong><br>    存储在栈（stack）中的简单数据段，也就是说，他们的值直接存储在变量访问的位置。</p><p><strong>引用值</strong><br>    存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</p><p><u>详细解释参考</u><a href="http://www.w3school.com.cn/js/pro_js_value.asp" target="_blank" rel="noopener">ECMAScript 原始值和引用值</a></p><p><img src="en-resource://database/578:1" alt="605dab694f82b63cc18932fd31dcc537.gif"></p><blockquote><p>ECMAScript 6 引入了一种新的原始类型： <strong>symbol</strong> 。</p></blockquote><h6 id="验证输出"><a href="#验证输出" class="headerlink" title="验证输出"></a>验证输出</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><span class="hljs-comment">// Array</span><br><span class="hljs-keyword">var</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;]<br><span class="hljs-keyword">var</span> ary2 = ary.valueOf()<br><span class="hljs-built_in">console</span>.log( ary2 ) <span class="hljs-comment">// [1, "a", f]</span><br><span class="hljs-built_in">console</span>.log( ary == ary2 ) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log( ary === ary2 ) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Boolean</span><br><span class="hljs-keyword">var</span> bool = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> bool2 = bool.valueOf()<br><span class="hljs-comment">// ...同上</span><br><br><span class="hljs-comment">// new Boolean</span><br><span class="hljs-keyword">var</span> bool3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">var</span> bool4 = bool3.valueOf()<br><span class="hljs-built_in">console</span>.log(bool3, bool4) <span class="hljs-comment">// Boolean &#123;true&#125;, true</span><br><span class="hljs-built_in">console</span>.log(bool3 == bool4) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(bool3 === bool4) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// Date</span><br><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">7</span>, <span class="hljs-number">18</span>, <span class="hljs-number">23</span>, <span class="hljs-number">11</span>, <span class="hljs-number">59</span>, <span class="hljs-number">230</span>);<br><span class="hljs-built_in">console</span>.log(date.valueOf());   <span class="hljs-comment">// 1376838719230</span><br><br><span class="hljs-comment"><code class="language-hljs javascript"><span class="hljs-comment">// Array</span><br><span class="hljs-keyword">var</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-string">'a'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;]<br><span class="hljs-keyword">var</span> ary2 = ary.valueOf()<br><span class="hljs-built_in">console</span>.log( ary2 ) <span class="hljs-comment">// [1, "a", f]</span><br><span class="hljs-built_in">console</span>.log( ary == ary2 ) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log( ary === ary2 ) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Boolean</span><br><span class="hljs-keyword">var</span> bool = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> bool2 = bool.valueOf()<br><span class="hljs-comment">// ...同上</span><br><br><span class="hljs-comment">// new Boolean</span><br><span class="hljs-keyword">var</span> bool3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">var</span> bool4 = bool3.valueOf()<br><span class="hljs-built_in">console</span>.log(bool3, bool4) <span class="hljs-comment">// Boolean &#123;true&#125;, true</span><br><span class="hljs-built_in">console</span>.log(bool3 == bool4) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(bool3 === bool4) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// Date</span><br><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">7</span>, <span class="hljs-number">18</span>, <span class="hljs-number">23</span>, <span class="hljs-number">11</span>, <span class="hljs-number">59</span>, <span class="hljs-number">230</span>);<br><span class="hljs-built_in">console</span>.log(date.valueOf());   <span class="hljs-comment">// 1376838719230</span><br><br><span class="hljs-comment">// ... and so on</span><br></code></pre></td></tr></table></figure><h5 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h5><p>近期看到的一道面试题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs javascript"><br><span class="hljs-keyword">var</span> result = +&#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'10'</span> &#125;,<br>    <span class="hljs-attr">valueOf</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">100</span> &#125;<br>&#125;<br><br><span class="hljs-built_in"><code class="language-hljs javascript"><br><span class="hljs-keyword">var</span> result = +&#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">toString</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'10'</span> &#125;,<br>    <span class="hljs-attr">valueOf</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">100</span> &#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(result)<br></code></pre></td></tr></table></figure></p><p>结果是 100<br>此处考点有对象的类型转化、toString() 和 valueOf() 调用的优先程度。</p>]]></content>
    
    <summary type="html">
    
      valueOf
描述
valueOf方法是将对象转换为“原始值”

默认情况下，valueOf方法由Object后面的每个对象继承。

如果对象没有原始值，则valueOf将返回对象本身。

对象返回值Array返回数组对象本身Boolean布尔值Date存储的时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC。Function函数本身Number数值Object对象本身String字符串值Math 和 Error 对象没有valueOf方法什么是原始值
在ECMAScript中，变量可以存在两种类型的值，即原始值和引用值。

原始值
存储在栈（stack）中的简单数据段，也就是
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://wty625073563.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>工作中踩坑记录</title>
    <link href="https://wty625073563.github.io/blog/2019/01/05/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://wty625073563.github.io/blog/2019/01/05/工作中踩坑记录/</id>
    <published>2019-01-05T15:49:54.000Z</published>
    <updated>2020-04-17T14:59:12.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="START"><a href="#START" class="headerlink" title="START"></a>START</h2><p>&emsp;&emsp;记录了一些初学到工作中出现一些问题，时常感叹自己是不是个傻子，菜成💩💩。</p><p>&emsp;&emsp;如没必要，不会浪费文字说明什么是什么。</p><p><strong>持续更新</strong><br><em>那就代表我有很多坑,有多菜</em></p><a id="more"></a><h2 id="CSS-position"><a href="#CSS-position" class="headerlink" title="CSS:position"></a>CSS:<strong>position</strong></h2><p>坑：position中两种定位方式：<strong>relative</strong>，<strong>fixed</strong></p><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>我还记得我学习position那端时间，不理解什么叫文档流，然后我就会具象一个三维的画面，而脱离文档流，就相当于脱离了同一纬度的空间。</p><p>而relative这个属性，在之前我一直认为是不会脱离文档流的。但实际工作中遇到类似这种情况 <a href="https://codepen.io/wty625073563/pen/ebMVox" target="_blank" rel="noopener">在线例子</a>。<br><br><br>我就会存有疑问，真的还在文档流当中吗？</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">MDN</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs undefined"><code class="language-hljs undefined">relative<br>  该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。<br></code></pre></td></tr></table></figure></p><p>拷问两兄弟(Google and Baidu)，查阅了一些文章，其中<a href="https://xhuyq.me/2017/09/27/relative-in-flow/" target="_blank" rel="noopener">CSS中”position:relative”属性与文档流的确切关系</a>也确实论证了”position:relative”<strong>实际上</strong>是不会脱离文档流的。</p><p>究竟是啥回事？？<br>我再延伸和深入进去看，发现事情没那么简单，需要一定的篇幅阐述。<br>详：<a href="https://wty625073563.github.io/blog/2019/01/05/CSS-position%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/">CSS-position主要属性分析</a></p>]]></content>
    
    <summary type="html">
    
      START
记录了一些初学到工作中出现一些问题，时常感叹自己是不是个傻子，菜成💩💩。

如没必要，不会浪费文字说明什么是什么。

持续更新
那就代表我有很多坑,有多菜

CSS:position
坑：position中两种定位方式：relative，fixed

relative
我还记得我学习position那端时间，不理解什么叫文档流，然后我就会具象一个三维的画面，而脱离文档流，就相当于脱离了同一纬度的空间。

而relative这个属性，在之前我一直认为是不会脱离文档流的。但实际工作中遇到类似这种情况 在线例子。


我就会存有疑问，真的还在文档流当中吗？

MDN：
1
2


r
    
    </summary>
    
    
      <category term="踩坑" scheme="https://wty625073563.github.io/blog/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>CSS.position主要属性分析</title>
    <link href="https://wty625073563.github.io/blog/2019/01/05/CSS-position%E4%B8%BB%E8%A6%81%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <id>https://wty625073563.github.io/blog/2019/01/05/CSS-position主要属性分析/</id>
    <published>2019-01-05T15:48:18.000Z</published>
    <updated>2020-04-17T14:59:12.480Z</updated>
    
    <content type="html"><![CDATA[<p>待<br><a id="more"></a></p><h5 id="todo"><a href="#todo" class="headerlink" title="todo:"></a>todo:</h5><ul><li>出发点，从position：relative。相对定位开始</li><li>为什么相对定位，会导致层级改变</li><li>引出层叠顺序</li><li>延伸，层叠上下文</li><li>结论</li><li>再延伸：absolute</li><li>absolute定位与float关系，使用absolute要注意的地方</li><li>fixed</li><li>fixed定位，基于浏览器窗口</li><li>但遇到某些情况，会导致fixed失效</li></ul>]]></content>
    
    <summary type="html">
    
      待


todo:
 * 出发点，从position：relative。相对定位开始
 * 为什么相对定位，会导致层级改变
 * 引出层叠顺序
 * 延伸，层叠上下文
 * 结论
 * 再延伸：absolute
 * absolute定位与float关系，使用absolute要注意的地方
 * fixed
 * fixed定位，基于浏览器窗口
 * 但遇到某些情况，会导致fixed失效
    
    </summary>
    
    
      <category term="CSS" scheme="https://wty625073563.github.io/blog/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>一切的开始</title>
    <link href="https://wty625073563.github.io/blog/2019/01/02/hello/"/>
    <id>https://wty625073563.github.io/blog/2019/01/02/hello/</id>
    <published>2019-01-02T08:29:17.000Z</published>
    <updated>2020-04-17T14:59:12.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>一切事物都有头有尾，这篇就相当于开头吧。<br>我的文笔不好，不想将就的话就将就得看吧。</p><a id="more"></a><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>&emsp;&emsp;在2017年1月份开始接触编程，因为好奇心与其不菲的薪资吸引了我走上了这条路，5月，我利用<a href="https://cn.wordpress.org/" target="_blank" rel="noopener">Wordpress</a>搭建自己的博客， 但弄着弄着发现，嗯~好像限制有点多，主题什么的都是内置不能自定义，而我在视觉上是有一定追求的人。之后手写了一个博客搭建在<a href="https://www.sinacloud.com/" target="_blank" rel="noopener">新浪云</a>上。</p><h2 id="新浪云"><a href="#新浪云" class="headerlink" title="新浪云"></a>新浪云</h2><p>&emsp;&emsp;手写的所谓博客，无非就是弄了一个比较酷炫的首页，然后在首页加上导航页，导航页的内容我依稀记得有：<strong>首页、HTML、CSS、JAVASCTRIPT、VUE全家桶、小游戏</strong>。</p><p>&emsp;&emsp;这里面记录了当初，我面对“神秘”的编程（在我没了解之前，我总是很多疑问，编程是什么，为什么可以做到这些？），原谅我才疏学浅，我到现在为止，也不能很清楚地回答这些类似的问题，所以我也在不断探索，即使在前进的道路上面对着很多无奈，现实的种种问题，但始终心有不甘，保有那份知道真相的心。</p><p>&emsp;&emsp;哎呀，扯得老远了，回到正题，这里面记录了我当初在学前端三剑客HTML/CSS/JS的一些感悟和过程，同时也记录了一些学习时的项目。而VUE，也就是实用VUE全家桶做的一个小小的项目（DEMO），小游戏就不说了，那时候乱弄的一些小游戏。</p><p>&emsp;&emsp;自从在18年7月份开始工作，就再也没有更新和维护了，也因此新浪云欠费，把我整个云端的库给删没了，资料也就都没了（电脑硬盘烂了，本地没保存）。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>&emsp;&emsp;至今，还在这家公司工作，从满怀激情的一边为公司创造价值一边学习深化自己的基础知识，到现在渐渐迷茫。生活及编程路上80%的时间和精力花在业务代码上，总感觉自己慢慢麻木了，当自己学着尝试改变现状。而这时候自己才发现。oh no！自己一直在龟速前行，学习如逆水行走，不进则退。水很急，进得太慢，如同原地踏水，只不过水早就不是原来的水，哈哈哈，强行文学。不过这对于自己现在的状态形容得很贴切。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>必须找对方法，跟上脚步了。<br>新的一年，大家一起加油吧！</p><p>最后，希望大家工作后记住一句话：</p><blockquote><p>生于忧患，死于安乐。</p></blockquote><p>完。</p>]]></content>
    
    <summary type="html">
    
      缘由
一切事物都有头有尾，这篇就相当于开头吧。
我的文笔不好，不想将就的话就将就得看吧。

博客
在2017年1月份开始接触编程，因为好奇心与其不菲的薪资吸引了我走上了这条路，5月，我利用Wordpress搭建自己的博客， 但弄着弄着发现，嗯~好像限制有点多，主题什么的都是内置不能自定义，而我在视觉上是有一定追求的人。之后手写了一个博客搭建在新浪云上。

新浪云
手写的所谓博客，无非就是弄了一个比较酷炫的首页，然后在首页加上导航页，导航页的内容我依稀记得有：首页、HTML、CSS、JAVASCTRIPT、VUE全家桶、小游戏。

这里面记录了当初，我面对“神秘”的编程（在我没了解之前，我总是很
    
    </summary>
    
    
      <category term="随笔" scheme="https://wty625073563.github.io/blog/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
